  http协议的无状态 如www.taobao.com/index服务器并不知道是哪个用户发来的请求
因而需要一些东西来标识用户 cookie 和 session  区别在于两个存放的位置不同
  cookie--Cookie是浏览器（User Agent）访问一些网站后，这些网站存放在客户端的一组数据，用于使网站等跟踪用户，实现用户自定义功能。cookie是一个txt的文件 即一串字符串 设置过期时间就长期保存否则关了浏览器就删除了

----如服务器将加密后的user id 和passwd 存放在浏览器一个cookie文件里 当用户请求taobao.com/购物车   的时候，浏览器将这个cookie一起发送给taobao  服务器就知道这是 谁谁谁 发来的了 
	详细：
	Cookie的Domain和Path属性标识了这个Cookie是哪一个网站发送给浏览器的；Cookie的Expires属性标识了Cookie的有 效时间，当Cookie的有效时间过了之后，这些数据就被自动删除了。
	
	如果不设置过期时间，则表示这个Cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，Cookie就消失了。这种生命期为浏览会话期的 Cookie被称为会话Cookie。会话Cookie一般不保存在硬盘上而是保存在内存里。如果设置了过期时间，浏览器就会把Cookie保存到硬盘 上，关闭后再次打开浏览器，这些Cookie依然有效直到超过设定的过期时间。存储在硬盘上的Cookie可以在不同的浏览器进程间共享，比如两个IE窗 口。而对于保存在内存的Cookie，不同的浏览器有不同的处理方式。
session
（
	如 session[MD5(user列表123等)==sessionid]<---->user_name 
	性能需要的话session应该是放在内存中访问快嘛，隔一段时间会删除;存硬盘上的数据库 io慢
）
  Session是存放在服务器端的类似于HashTable结构（hashtable和hashmap有不同的地方，说白了就是一些键值对 {key：value}，如userid-经过hash函数-随机生成一个散列表中的位置-存value  取值：hash对象.get（id）==真实的id号 好处 O（1））来存放用户数据，当浏览器第一次发送请求时，服务器自动生成了一个session（HashTable）和一个Session ID用来唯一标识这个HashTable（session），并将其（sessionID）通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的SessionID放在请求中一并发送到服务器上，服务器从请求中提取出SessionID，并和保存的所有SessionID进行对比判断，找到这个用户对应的HashTable（session）。信息


token就是令牌session token

	通过session token防止重复提交:

=================================================================
静态请求用前段服务器 apache等  需要处理的动态 session到tomcat 注意同步session问题 不同的web容器
MD5  一种加密方式基本上可以说MD5[string]后得到的字符串不重复不可逆吧
不可逆性

这个特征码有如下特性，首先它不可逆，例如我有一段秘密的文字如："My Secret Words"，经算法变换后得到MD5码(b9944e9367d2e40dd1f0c4040d4daaf7)，把这个码告诉其他人，他们根据这个MD5码是没有系统的方法可以知道你原来的文字是什么的。
离散性

其次，这个码具有高度的离散性，也就是说，原信息的一点点变化就会导致MD5的巨大变化，例如"ABC" MD5(902fbdd2b1df0c4f70b4a5d23525e932)和"ABC "（多了一空格）MD5(12c774468f981a9487c30773d8093561)差别非常大，而且之间没有任何关系，也就是说产生的MD5码是不可预测的。
码位性

最后由于这个码有128位那么长，所以任意信息之间具有相同MD5码的可能性非常之低，通常被认为是不可能的。
如 username和passwd md5后存到数据库 安全 当用户登录时，同样假设用户在名为password的文本框中设置了密码，只需再做如下运算
        password.Text=System.Web.Security.FormsAuthentication.HashPasswordForStoringInConfigFile(password.Text, "MD5");//将这个值送入数据库进行比对，就知道登录时输入的密码和注册时输入的密码是否一样了


==============================================================

1   broser                      server

     url   --------->     产生session(hash)+seesionID
     cookie<----------    sessionid
	 cookie （1 设置时效2url中get3隐藏表单post发送）
     cookie---sessionid--->查sessionid||（token重复性验证）

----分割线---------------一些细节=记住我的讨论 可以不用看 ---------------------------------------------分割线-------------------------------------------------------------------------------------------------------------------------------
	当客户端请求页面时，服务器会通过token标签生成一个随机数，并且将随机数放置到session当中，然后将随机数发向客户端；如果客户第一次提交，那么浏览器会将该随机数发往服务器，服务器端会接收到该随机数并且与session中所保存的随机数进行比较，这时两者的值是相同的，服务器认为是第一次提交,并且将更新服务器端的这个随机数值；如果此时再次重复提交，那么客户端向服务器端的随机数还是之前的那个，而服务器端的随机数则已经发生了变化，两者不同，服务器就认为这事重复提交，进而转向invalid.token所指向的结果页面。

	Token一般用在两个地方:

		1)防止表单重复提交、
			服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。
		2)anti csrf攻击（跨站点请求伪造）

			此外，要避免“加token但不进行校验”的情况，在session中增加了token，但服务端没有对token进行验证，根本起不到防范的作用。

			还需注意的是，对数据库有改动的增删改操作，需要加token验证，对于查询操作，一定不要加token，防止攻击者通过查询操作获取token进行csrf攻击。但并不是这样攻击者就无法获得token，只是增大攻击成本而已。



要使用Session -----   http://www.cnblogs.com/sharpxiajun/p/3395607.html
	第一步当然是创建Session了。那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法，而在Java中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。正式这样一个过程，用户的状态也就得以保持了。
	
	cookie和session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用
session计算的开销
		为了弥补http协议的无状态的特点，服务端会占用一定的内存和cpu用来存储和处理session计算的开销，这也就是tomcat这个的web容器的并发连接那么低（tomcat官方文档里默认的连接数是200）原因之一 
				因此很多java语言编写的网站，在生产环境里web容器之前会加一个静态资源服务器，例如：apache服务器或nginx服务器，静态资源服务器没有解决http无状态问题的功能，因此部署静态资源的服务器也就不会让出内存或cpu计算资源专门去处理像session这样的功能，这些内存和cpu资源可以更有效的处理每个http请求，因此静态资源服务器的并发连接数更高，所以我们可以让那些没有状态保持要求的请求直接在静态服务器里处理，而要进行状态保持的请求则在java的web容器里进行处理，这样能更好的提升网站的效率。
				当下的互联网网站为了提高网站安全性和并发量，服务端的部署的服务器的数量往往是大于或等于两台，多台服务器对外提供的服务是等价的，但是不同的服务器上面肯定会有不同的web容器，由上面的讲述我们知道session的实现机制都是web容器里内部机制，这就导致一个web容器里所生成的session的id值是不同的，因此当一个请求到了A服务器，浏览器得到响应后，客户端存下的是A服务器上所生成的session的id，当在另一个请求分发到了B服务器，B服务器上的web容器是不能识别这个session的id值，更不会有这个sessionID所对应记录下来的信息，这个时候就需要两个不同web容器之间进行session的同步。Tomcat容器有一个官方的解决方案就是使用apache+tomcat+mod_jk方案，当一个web容器里session的信息发生变化后，该web容器会向另一个web容器进行广播，另一个web收到广播后将session信息同步到自己的容器里，这个过程是十分消耗系统资源，当访问量增加会严重影响到网站的效率和稳定性。

session、cookie与“记住我的登录状态”的功能的实现
	Cookie的机制

	Cookie是浏览器（User Agent）访问一些网站后，这些网站存放在客户端的一组数据，用于使网站等跟踪用户，实现用户自定义功能。

	Cookie的Domain和Path属性标识了这个Cookie是哪一个网站发送给浏览器的；Cookie的Expires属性标识了Cookie的有 效时间，当Cookie的有效时间过了之后，这些数据就被自动删除了。

	如果不设置过期时间，则表示这个Cookie生命周期为浏览器会话期间，只要关闭浏览器窗口，Cookie就消失了。这种生命期为浏览会话期的 Cookie被称为会话Cookie。会话Cookie一般不保存在硬盘上而是保存在内存里。如果设置了过期时间，浏览器就会把Cookie保存到硬盘 上，关闭后再次打开浏览器，这些Cookie依然有效直到超过设定的过期时间。存储在硬盘上的Cookie可以在不同的浏览器进程间共享，比如两个IE窗 口。而对于保存在内存的Cookie，不同的浏览器有不同的处理方式。

	Session的机制

	Session是存放在服务器端的类似于HashTable结构（每一种Web开发技术的实现可能不一样，下文直接称之为HashTable）来存放用户数据，当浏览器第一次发送请求时，服务器自动生成了一个HashTable和一个Session ID用来唯一标识这个HashTable，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的SessionID放在请求中一并发送到服务器上，服务器从请求中提取出SessionID，并和保存的所有SessionID进行对比，找到这个用户对应的HashTable。

	一般情况下，服务器会在一定时间内（默认20分钟）保存这个HashTable，过了时间限制，就会销毁这个HashTable。在销毁之前，程序员可以 将用户的一些数据以Key和Value的形式暂时存放在这个HashTable中。当然，也有使用数据库将这个HashTable序列化后保存起来的，这 样的好处是没了时间的限制，坏处是随着时间的增加，这个数据库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。

	Session的客户端实现形式（即Session ID的保存方法）

	一般浏览器提供了两种方式来保存，还有一种是程序员使用HTML隐藏域的方式自定义实现：

	[1] 使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。

	[2] 使用URL附加信息的方式，也就是像我们经常看到JSP网站会有aaa.jsp?JSESSIONID=*一样的。这种方式和第一种方式里面不设置 Cookie过期时间是一样的。

	[3] 第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后 者比较麻烦。

	实现“记住我的登录状态”的功能

	前面我们了解到，如果我们将Session ID通过Cookie发送到客户端的时候设置其过期时间为1年，那么在今后的一年时间内，客户端访问我的网站的时候都回将这个Session ID值发送到服务器上，服务器根据这个Session ID从内存或者数据库里面恢复存放Key-Value对的Hashtable。
当底下是胡扯 不看了---------------
	其实这已经很好的实现了我们的功能了。但是，前面也提到了，实际上Session并不会一直都存在的，过了一定的时间之后，服务器上的Session就被 销毁了，以减轻服务器的访问压力。当服务器上的数据被销毁后，即使客户端上存放了Cookie也没有办法“记住我的登录状态”了。

	
	到目前为止，已经基本明确了“记住我的登录状态”的实现方式和理论依据，后文将使用jsp和php两种Web开发技术来具体实现这个功能。